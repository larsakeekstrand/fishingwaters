#!/usr/bin/env python3
"""
GitHub Issue Helper - A tool to manage GitHub issues from the command line.

This script can list open issues, show issue details, and download issues to Markdown files
with a plan generated by Claude for how to fix the issue.
"""

import argparse
import json
import os
import requests
import subprocess
import sys
from datetime import datetime
from pathlib import Path
from urllib.parse import urljoin
from dotenv import load_dotenv


def load_env_from_file():
    """Load environment variables from .env file if it exists."""
    env_path = Path('.env')
    if env_path.exists():
        load_dotenv()

def parse_arguments():
    """Parse command line arguments."""
    # Load env variables from .env file if it exists
    load_env_from_file()

    parser = argparse.ArgumentParser(description="GitHub Issue Helper")

    # Common arguments
    parser.add_argument("--repo", required=False, help="Repository in format 'owner/repo'")
    parser.add_argument("--token", help="GitHub API token (or set GITHUB_TOKEN env variable)")

    # Create subparsers for different commands
    subparsers = parser.add_subparsers(dest="command", help="Command to execute")

    # List issues command
    list_parser = subparsers.add_parser("list", help="List all open issues")

    # Show issue details command
    show_parser = subparsers.add_parser("show", help="Show details about a specific issue")
    show_parser.add_argument("issue_number", type=int, help="Issue number to show")

    # Download and plan issue command
    plan_parser = subparsers.add_parser("plan", help="Download issue and generate a plan with Claude")
    plan_parser.add_argument("issue_number", type=int, help="Issue number to plan")
    plan_parser.add_argument("--deep-thinking", action="store_true",
                            help="Tell Claude to think deeply about the best approach")

    args = parser.parse_args()

    # Validate command
    if not args.command:
        parser.print_help()
        sys.exit(1)

    # Try to get repo from environment if not provided
    if not args.repo:
        args.repo = os.environ.get("GITHUB_REPO")
        if not args.repo:
            print("Error: GitHub repository is required. Provide it with --repo or set GITHUB_REPO env variable.")
            sys.exit(1)

    # Get token from environment if not provided
    if not args.token:
        args.token = os.environ.get("GITHUB_TOKEN")
        if not args.token:
            print("Error: GitHub token is required. Provide it with --token or set GITHUB_TOKEN env variable.")
            sys.exit(1)

    return args


def get_github_headers(token):
    """Create headers for GitHub API requests."""
    return {
        "Authorization": f"token {token}",
        "Accept": "application/vnd.github.v3+json"
    }


def list_issues(repo, token):
    """List all open issues for the given repository."""
    api_url = f"https://api.github.com/repos/{repo}/issues"
    params = {"state": "open", "sort": "created", "direction": "desc"}
    
    response = requests.get(api_url, headers=get_github_headers(token), params=params)
    
    if response.status_code != 200:
        print(f"Error: Unable to fetch issues. Status code: {response.status_code}")
        print(response.json().get("message", ""))
        sys.exit(1)
        
    issues = response.json()
    
    if not issues:
        print("No open issues found.")
        return
        
    print(f"Open issues for {repo}:")
    for issue in issues:
        # Skip pull requests
        if "pull_request" in issue:
            continue
            
        print(f"#{issue['number']} - {issue['title']}")
        print(f"  Created: {issue['created_at']} | Updated: {issue['updated_at']}")
        print(f"  URL: {issue['html_url']}")
        print()


def get_issue_details(repo, token, issue_number):
    """Get detailed information about a specific issue."""
    api_url = f"https://api.github.com/repos/{repo}/issues/{issue_number}"
    
    response = requests.get(api_url, headers=get_github_headers(token))
    
    if response.status_code != 200:
        print(f"Error: Unable to fetch issue #{issue_number}. Status code: {response.status_code}")
        print(response.json().get("message", ""))
        sys.exit(1)
        
    issue = response.json()
    
    # Check if it's a pull request
    if "pull_request" in issue:
        print(f"Error: #{issue_number} is a pull request, not an issue.")
        sys.exit(1)
        
    return issue


def show_issue(repo, token, issue_number):
    """Show details about a specific issue."""
    issue = get_issue_details(repo, token, issue_number)
    
    print(f"Issue #{issue['number']}: {issue['title']}")
    print(f"State: {issue['state']}")
    print(f"Created: {issue['created_at']} | Updated: {issue['updated_at']}")
    print(f"URL: {issue['html_url']}")
    print()
    
    if issue['body']:
        print("Description:")
        print(issue['body'])
    else:
        print("No description provided.")
    
    print()
    
    if issue['labels']:
        print("Labels:", ", ".join([label['name'] for label in issue['labels']]))
    
    if issue['assignees']:
        print("Assignees:", ", ".join([assignee['login'] for assignee in issue['assignees']]))
    
    print(f"Comments: {issue['comments']}")


def ensure_issues_directory():
    """Ensure the issues directory exists."""
    issues_dir = os.path.join(os.getcwd(), "issues")
    if not os.path.exists(issues_dir):
        os.makedirs(issues_dir)
    return issues_dir


def format_issue_markdown(issue):
    """Format issue details as Markdown."""
    md = f"# Issue #{issue['number']}: {issue['title']}\n\n"
    md += f"- **State:** {issue['state']}\n"
    md += f"- **Created:** {issue['created_at']}\n"
    md += f"- **Updated:** {issue['updated_at']}\n"
    md += f"- **URL:** {issue['html_url']}\n\n"
    
    if issue['labels']:
        md += "## Labels\n\n"
        for label in issue['labels']:
            md += f"- {label['name']}\n"
        md += "\n"
    
    if issue['assignees']:
        md += "## Assignees\n\n"
        for assignee in issue['assignees']:
            md += f"- {assignee['login']}\n"
        md += "\n"
    
    md += "## Description\n\n"
    if issue['body']:
        md += issue['body']
    else:
        md += "*No description provided.*"
    
    md += "\n\n"
    
    return md


def get_issue_comments(repo, token, issue_number):
    """Get all comments for an issue."""
    api_url = f"https://api.github.com/repos/{repo}/issues/{issue_number}/comments"
    
    response = requests.get(api_url, headers=get_github_headers(token))
    
    if response.status_code != 200:
        print(f"Error: Unable to fetch comments for issue #{issue_number}. Status code: {response.status_code}")
        return []
        
    return response.json()


def format_comments_markdown(comments):
    """Format issue comments as Markdown."""
    if not comments:
        return "## Comments\n\n*No comments*\n\n"
    
    md = "## Comments\n\n"
    for comment in comments:
        md += f"### {comment['user']['login']} commented on {comment['created_at']}\n\n"
        md += comment['body']
        md += "\n\n---\n\n"
    
    return md


def get_claude_plan(issue_markdown, deep_thinking=False):
    """Generate a plan using Claude CLI."""
    try:
        # Prepare Claude prompt
        prompt = f"Please create a plan for how to fix this issue:\n\n{issue_markdown}\n\n"
        
        if deep_thinking:
            prompt += " Think deeply about the best approach for implementing this."
        
        # Call Claude CLI
        result = subprocess.run(
            ["claude", "--allowedTools", "Task", "Bash", "Edit", "Write", "-p", prompt],
            capture_output=True,
            text=True
        )
        
        if result.returncode != 0:
            print(f"Error running Claude CLI: {result.stderr}")
            return "\n\n## Plan (Claude failed to generate)\n\n*Failed to generate plan using Claude CLI*\n\n"
        
        claude_response = result.stdout.strip()
        return f"\n\n## Plan (Generated by Claude)\n\n{claude_response}\n"
    
    except Exception as e:
        print(f"Error generating plan with Claude: {str(e)}")
        return "\n\n## Plan (Claude failed to generate)\n\n*Failed to generate plan using Claude CLI*\n\n"


def plan_issue(repo, token, issue_number, deep_thinking=False):
    """Download issue and generate a plan with Claude."""
    # Get issue details
    issue = get_issue_details(repo, token, issue_number)
    
    # Get issue comments
    comments = get_issue_comments(repo, token, issue_number)
    
    # Format as Markdown
    issue_md = format_issue_markdown(issue)
    comments_md = format_comments_markdown(comments)
    
    full_md = issue_md + comments_md
    
    # Generate plan with Claude
    print(f"Generating plan for issue #{issue_number} with Claude...")
    plan_md = get_claude_plan(full_md, deep_thinking)
    
    # Save to file
    issues_dir = ensure_issues_directory()
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    filename = f"ISSUE-{issue_number}_{timestamp}.md"
    filepath = os.path.join(issues_dir, filename)
    
    with open(filepath, "w") as f:
        f.write(full_md + plan_md)
    
    print(f"Issue downloaded and plan generated: {filepath}")


def main():
    """Main entry point for the script."""
    args = parse_arguments()
    
    if args.command == "list":
        list_issues(args.repo, args.token)
    elif args.command == "show":
        show_issue(args.repo, args.token, args.issue_number)
    elif args.command == "plan":
        plan_issue(args.repo, args.token, args.issue_number, args.deep_thinking)


if __name__ == "__main__":
    main()